/***************************************************************/
/* This class was generated by ds-to-spi-annotations-processor */
/***************************************************************/

#if( ${component.packageName} )
package ${component.packageName};

#end
public class ${component.spiClassName}
#if( !${component.proxy} )
       extends ${component.qualifiedClassName}
#end
       implements org.daisy.common.spi.ServiceWithProperties
#if( ${component.immediate} )
                , org.daisy.common.spi.CreateOnStart ## maybe this is not exactly what we want but it's close enough
#end
#if( ${component.proxy} )
#foreach($service in ${component.services})
                , ${service.name}
#end
#end
{
	
	private static final org.slf4j.Logger spi_log = org.slf4j.LoggerFactory.getLogger(${component.spiClassName}.class);
	
	private final java.util.Map spi_props;
	private boolean spi_deactivated = false;
	
#if( ${component.proxy} )
	private final ${component.qualifiedClassName} delegate;
#end

	public ${component.spiClassName}() {
#if( ${component.proxy} )
		delegate = new ${component.qualifiedClassName}();
#else
		super();
#end
		spi_log.trace("Creating ${component.className}");
		spi_props = new java.util.HashMap();
		spi_props.put("component.name", "${component.name}");
#foreach($property in ${component.properties})
		spi_props.put(${property.keyLiteral}, ${property.valueLiteral});
#end
#foreach($reference in ${component.references})
		{
			spi_log.trace("Binding ${reference.service} services...");
			// cardinality: ${reference.cardinality}
#if( ${reference.cardinality} == "1..1" )
			int minRef = 1;
			int maxRef = 1;
#elseif( ${reference.cardinality} == "1..n" )
			int minRef = 1;
			int maxRef = -1;
#elseif( ${reference.cardinality} == "0..1" )
			int minRef = 0;
			int maxRef = 1;
#else
			int minRef = 0;
			int maxRef = -1;
#end
			int refCount = 0;
			try {
				java.util.Iterator<${reference.service}> services
					= org.daisy.common.spi.ServiceLoader.load(${reference.service}.class).iterator();
#if( ${reference.filter} )
				 org.osgi.framework.Filter filter = org.osgi.framework.FrameworkUtil.createFilter(${reference.filter});
#end
				while (services.hasNext()) {
					try {
						${reference.service} service = services.next();
#if( ${reference.filter} )
						if (!filter.matches(((org.daisy.common.spi.ServiceWithProperties)service).spi_getProperties())) {
							spi_log.trace("Service " + service + " does not match " + ${reference.filter});
							continue; }
#end
#if( ${reference.propertiesArgumentType} )
						${reference.propertiesArgumentType.getName()} props = new ${reference.propertiesArgumentType.getName()}();
						for (java.util.Map.Entry kv : (java.util.Set<java.util.Map.Entry>)
								((org.daisy.common.spi.ServiceWithProperties)service).spi_getProperties().entrySet()) {
							props.put(kv.getKey(), kv.getValue());
						}
#end
#if( ${component.proxy} )
						delegate.${reference.methodName}(service#else
						${reference.methodName}(service#end
#if( ${reference.propertiesArgumentType} ), props#end
);
						spi_log.trace("Bound ${reference.service} service: "
						              + service.getClass().getName() + "@"
						              + Integer.toHexString(System.identityHashCode(service)));
						refCount++;
						if (maxRef > 0 && refCount == maxRef)
							break;
					} catch (Throwable e) {
						spi_log.error("Error while binding ${reference.service} service", e);
					}
				}
			} catch (Throwable e) {
				spi_log.error("Error while binding ${reference.service} services", e);
			}
			if (refCount < minRef) {
				spi_log.warn("No ${reference.service} found");
				throw new RuntimeException("No ${reference.service} found");
			} else {
				spi_log.trace("Bound " + refCount + " ${reference.service} services.");
			}
		}
#end
#if( ${component.activate} )
		spi_log.trace("Activating ${component.className}");
#if( ${component.activate.propertiesArgumentType} )
		${component.activate.propertiesArgumentType.getName()} props = new ${component.activate.propertiesArgumentType.getName()}();
		props.put("component.name", "${component.name}");
#foreach($property in ${component.properties})
		props.put(${property.keyLiteral}, ${property.valueLiteral});
#end
#end
#if( ${component.proxy} )
		delegate.${component.activate.methodName}(#else
		${component.activate.methodName}(#end
#if( ${component.activate.propertiesArgumentType} )props#end
);
#end
	}
#if( ${component.deactivate} )
	
	@Override
	protected void finalize() throws Throwable {
		spi_deactivate();
		super.finalize();
	}
#end
	
	public void spi_deactivate() {
#if( ${component.deactivate} )
		if (!spi_deactivated) {
			spi_log.trace("Deactivating ${component.className}");
			try {
				#if( ${component.proxy} )delegate.#end${component.deactivate.methodName}();
			} catch (Throwable e) {
				spi_log.error("Caught exception while deactivating ${component.className}", e);
			} finally {
				spi_deactivated = true;
			}
		}
#end
	}
	
	public java.util.Map spi_getProperties() {
		return spi_props;
	}
#if( ${component.proxy} )
#foreach($method in ${component.serviceMethods})

	@Override
	public ${method.returnType} ${method.name}(#if (${method.argumentTypes.size()} > 0)

#foreach($arg in ${method.argumentTypes})
		$arg arg${foreach.count}#if( $foreach.hasNext ),
#end
#end

	#end)#if (${method.thrownTypes.size()} > 0) throws #foreach($thrown in ${method.thrownTypes})$thrown#if( $foreach.hasNext )

	       , #end
#end
#end {
		#if( ${method.returnType} != 'void' )return #end
delegate.${method.name}(#if (${method.argumentTypes.size()} > 0)

#foreach($arg in ${method.argumentTypes})
			arg${foreach.count}#if( $foreach.hasNext ),
#end
#end

		#end);
	}
#end

	@Override
	public String toString() {
		return delegate.toString();
	}

	@Override
	public int hashCode() {
		return delegate.hashCode();
	}

	@Override
	public boolean equals(Object o) {
		return delegate.equals(o);
	}
#end
}
